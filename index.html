<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Metta Mandala - River of Compassion</title>
    <style>
        :root {
            --primary: #f9bf3b; /* Yellow as primary color */
            --secondary: #f1c40f; /* Slightly darker yellow */
            --accent: #f9bf3b;
            --accent-glow: rgba(249, 191, 59, 0.3);
            --text: #f5f5f5; /* Light text color */
            --light: #f5f5f5;
            --dark: #000000; /* Black */
            --shadow: rgba(0, 0, 0, 0.5);
            --transition: all 0.3s ease;
            --river-blue: #4ca1de;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Manrope', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: var(--dark);
            color: var(--text);
            line-height: 1.6;
            overflow-x: hidden;
        }
        
        h1, h2, h3, h4 {
            font-weight: 400;
            margin-bottom: 1rem;
        }
        
        p {
            margin-bottom: 1rem;
        }
        
        button {
            cursor: pointer;
            background: var(--primary);
            color: var(--dark);
            border: none;
            padding: 12px 20px;
            font-size: 16px;
            border-radius: 5px;
            transition: var(--transition);
            box-shadow: 0 2px 5px var(--shadow);
        }
        
        button:hover {
            background: var(--secondary);
            transform: translateY(-2px);
        }

        button.secondary {
            background: rgba(249, 191, 59, 0.3);
            color: var(--primary);
            border: 1px solid var(--primary);
        }

        button.secondary:hover {
            background: rgba(249, 191, 59, 0.4);
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }
        
        /* Header Styles */
        header {
            padding: 20px 0;
            background-color: #111;
            box-shadow: 0 2px 10px var(--shadow);
        }
        
        .logo {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 10px;
        }
        
        .logo h1 {
            font-size: 28px;
            margin: 0;
            color: var(--primary);
        }
        
        .logo svg {
            width: 40px;
            height: 40px;
            margin-right: 10px;
            fill: var(--primary);
        }

        /* Main Screen Styles */
        .main-screen {
            min-height: calc(100vh - 100px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px 20px;
            text-align: center;
        }
        
        .welcome-message {
            max-width: 600px;
            margin-bottom: 40px;
        }
        
        .welcome-message h2 {
            font-size: 32px;
            margin-bottom: 20px;
            color: var(--primary);
        }
        
        .welcome-message p {
            font-size: 18px;
            color: var(--text);
            margin-bottom: 20px;
        }
        
        .main-actions {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 100%;
            max-width: 400px;
        }
        
        .action-button {
            width: 100%;
            padding: 15px;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .action-button svg {
            margin-right: 10px;
            width: 24px;
            height: 24px;
        }

        /* Mandala Creation Screen */
        .creation-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            min-height: calc(100vh - 100px);
            padding: 20px;
        }
        
        .mandala-header {
            text-align: center;
            margin-bottom: 20px;
        }
        
        .mandala-header h2 {
            color: var(--primary);
            font-size: 28px;
            margin-bottom: 10px;
        }
        
        .mandala-header p {
            color: var(--text);
            max-width: 600px;
            margin: 0 auto;
        }
        
        .mandala-container {
            display: flex;
            justify-content: center;
            margin: 20px 0 40px;
        }
        
        .canvas-container {
            position: relative;
            width: 500px;
            height: 500px;
            margin: 0 auto;
        }
        
        canvas {
            display: block;
            background: black;
            border-radius: 50%;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.1);
        }
        
        .tools-panel {
            display: flex;
            flex-direction: column;
            margin-top: 20px;
            width: 100%;
            max-width: 800px;
            margin: 0 auto;
        }
        
        .level-indicator {
            text-align: center;
            margin-bottom: 20px;
        }
        
        .level-indicator h3 {
            font-size: 24px;
            color: var(--primary);
            margin-bottom: 5px;
        }
        
        .level-indicator p {
            color: var(--text);
            font-style: italic;
        }
        
        .color-tools {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .color-swatch {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            transition: var(--transition);
            border: 3px solid transparent;
        }
        
        .color-swatch:hover, .color-swatch.active {
            transform: scale(1.1);
            border: 3px solid var(--primary);
        }
        
        .color-white { background-color: #ffffff; border: 1px solid #333; }
        .color-blue { background-color: #3498db; }
        .color-yellow { background-color: #f1c40f; }
        .color-red { background-color: #e74c3c; }
        .color-green { background-color: #2ecc71; }
        .color-black { background-color: #111111; }
        
        .color-meaning {
            display: flex;
            justify-content: center;
            margin-top: 20px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .color-meaning-item {
            display: flex;
            align-items: center;
            margin: 0 10px;
        }

        .color-meaning-dot {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            margin-right: 5px;
        }
        
        .level-navigation {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 30px;
        }

        /* Final Screen */
        .final-screen {
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: calc(100vh - 100px);
            padding: 40px 20px;
            text-align: center;
        }

        .final-mandala {
            width: 300px;
            height: 300px;
            margin: 30px 0;
            position: relative;
        }

        .final-mandala canvas {
            position: absolute;
            top: 0;
            left: 0;
            border-radius: 50%;
        }

        .final-mandala .glow {
            position: absolute;
            top: -20px;
            left: -20px;
            width: calc(100% + 40px);
            height: calc(100% + 40px);
            background: radial-gradient(circle, var(--accent-glow) 0%, rgba(255,215,0,0) 70%);
            border-radius: 50%;
            z-index: -1;
        }

        .message-input {
            width: 100%;
            max-width: 500px;
            margin: 20px 0;
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #444;
            resize: none;
            font-size: 16px;
            background-color: #222;
            color: var(--text);
        }

        /* Sand Mandala Transition Screen */
        .sand-transition-screen {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, #000000 0%, #1a1a2e 100%);
            z-index: 100;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            color: white;
            text-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }

        .transition-mandala {
            width: 300px;
            height: 300px;
            position: relative;
            margin-bottom: 20px;
        }

        .sand-mandala-canvas {
            border-radius: 50%;
            background: transparent;
            box-shadow: 0 0 30px var(--accent-glow);
        }

        /* River View */
        .river-view {
            display: none;
            width: 100%;
            height: 100vh;
            position: relative;
            overflow: hidden;
            background: linear-gradient(180deg, #000000 0%, #1a1a2e 100%);
        }

        .river-info {
            position: absolute;
            top: 20px;
            left: 0;
            width: 100%;
            text-align: center;
            color: white;
            text-shadow: 0 1px 3px rgba(0,0,0,0.3);
            padding: 20px;
            z-index: 10;
        }

        .river-info h2 {
            font-size: 32px;
            margin-bottom: 10px;
            color: var(--primary);
        }

        .river-info p {
            font-size: 18px;
            max-width: 600px;
            margin: 0 auto 20px;
        }

        .river {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 60%;
            background: #1a1a2e;
            overflow: hidden;
        }

        .river-wave {
            position: absolute;
            top: -50px;
            left: 0;
            width: 200%;
            height: 60px;
            background: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1440 320'%3E%3Cpath fill='%231a1a2e' fill-opacity='1' d='M0,192L48,186.7C96,181,192,171,288,181.3C384,192,480,224,576,224C672,224,768,192,864,186.7C960,181,1056,203,1152,208C1248,213,1344,203,1392,197.3L1440,192L1440,320L1392,320C1344,320,1248,320,1152,320C1056,320,960,320,864,320C768,320,672,320,576,320C480,320,384,320,288,320C192,320,96,320,48,320L0,320Z'%3E%3C/path%3E%3C/svg%3E");
            background-repeat: repeat-x;
            animation: wave 20s linear infinite;
        }

        @keyframes wave {
            0% { transform: translateX(0); }
            100% { transform: translateX(-50%); }
        }

        .river-mandala {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background-color: black;
            cursor: pointer;
            box-shadow: 0 0 15px var(--accent-glow);
            transform: translate(-50%, -50%);
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            z-index: 5;
            transition: transform 0.3s ease;
        }

        .river-mandala:hover {
            transform: translate(-50%, -50%) scale(1.1);
        }

        .mandala-particle {
            position: absolute;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: #e6d2a4;
            opacity: 0.8;
            box-shadow: 0 0 10px var(--accent);
            z-index: 2;
        }

        .river-controls {
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: center;
            gap: 20px;
            padding: 20px;
            z-index: 10;
        }

        .mandala-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #111;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.5);
            z-index: 1000;
            max-width: 80%;
            display: none;
            color: var(--text);
            text-shadow: none;
            border: 1px solid var(--primary);
        }

        .popup-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .popup-close {
            background: none;
            box-shadow: none;
            color: var(--primary);
            padding: 5px;
        }

        .popup-content {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .popup-mandala {
            width: 200px;
            height: 200px;
            border-radius: 50%;
            margin-bottom: 15px;
            background-size: cover;
            background-position: center;
            box-shadow: 0 0 15px var(--accent-glow);
        }

        .popup-message {
            font-style: italic;
            margin: 10px 0;
            color: #aaa;
        }

        .popup-date {
            font-size: 14px;
            color: #777;
        }

        /* Instructions */
        .instructions {
            margin-top: 20px;
            padding: 15px;
            background: rgba(249, 191, 59, 0.1);
            border-left: 4px solid var(--primary);
            border-radius: 4px;
            max-width: 800px;
            margin: 20px auto;
        }
        
        .instructions h3 {
            color: var(--primary);
            text-align: left;
            margin-bottom: 10px;
        }
        
        .instructions ul {
            padding-left: 20px;
        }
        
        .instructions li {
            margin-bottom: 8px;
        }

        /* Media Queries */
        @media (max-width: 768px) {
            .canvas-container {
                width: 300px;
                height: 300px;
            }
            
            .transition-mandala {
                width: 200px;
                height: 200px;
            }
        }
    </style>
</head>
<body>

    <!-- Main Home Screen -->
    <section class="main-screen" id="mainScreen">
        <div class="welcome-message">
            <h2>Welcome to Metta Mandala</h2>
            <p>Create mandalas of compassion and kindness. Each circle extends your love from yourself to all beings, creating a shared experience of peace and connection.</p>
        </div>
        <div class="main-actions">
            <button id="createBtn" class="action-button">
                <svg viewBox="0 0 24 24" width="24" height="24" fill="currentColor">
                    <path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/>
                </svg>
                Create a new Mandala
            </button>
            <button id="viewRiverBtn" class="action-button secondary">
                <svg viewBox="0 0 24 24" width="24" height="24" fill="currentColor">
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 17.93c-3.95-.49-7-3.85-7-7.93 0-.62.08-1.21.21-1.79L9 15v1c0 1.1.9 2 2 2v1.93zm6.9-2.54c-.26-.81-1-1.39-1.9-1.39h-1v-3c0-.55-.45-1-1-1H8v-2h2c.55 0 1-.45 1-1V7h2c1.1 0 2-.9 2-2v-.41c2.93 1.19 5 4.06 5 7.41 0 2.08-.8 3.97-2.1 5.39z"/>
                </svg>
                See the River of Mandalas
            </button>
        </div>
    </section>

    <!-- Mandala Creation Screen -->
    <section class="creation-screen" id="creationScreen">
        <div class="mandala-header">
            <h2 id="levelTitle">Self</h2>
            <p id="levelDescription">Firstly, we send love to ourselves.</p>
        </div>
        
        <div class="mandala-container">
            <div class="canvas-container">
                <canvas id="mandalaCanvas" width="500" height="500"></canvas>
            </div>
        </div>
        
        <div class="tools-panel">
            <div class="color-tools">
                <!-- Color swatches will be generated dynamically -->
            </div>
            
            <div class="color-meaning">
                <!-- Color meanings will be generated dynamically -->
            </div>
            
            <div style="height: 20px;"></div> <!-- Spacer -->
            
            <div class="level-navigation">
                <button id="clearBtn" class="secondary">Clear</button>
                <button id="backToHomeFromCreationBtn" class="secondary">Back to Home</button>
                <button id="prevLevelBtn" class="secondary">Previous</button>
                <button id="nextLevelBtn">Next</button>
            </div>
        </div>
    </section>

    <!-- Final Screen -->
    <section class="final-screen" id="finalScreen">
        <h2>Your mandala is complete.<br>Would you like to send it as a blessing to the world?</h2>
        
        <div class="final-mandala">
            <canvas id="finalMandalaCanvas" class= "sand-mandala-canvas" width="300" height="300"></canvas>
            <div class="glow"></div>
        </div>
        
        <textarea placeholder="Leave a message..." class="message-input" id="mandalaMsgInput">Hope you can have a good day!</textarea>
        
        <div class="level-navigation">
            <button id="backToEditBtn" class="secondary">Back</button>
            <button id="sendMandalaBtn">Send to others</button>
        </div>
    </section>

    <!-- Sand Mandala Transition Screen -->
    <section class="sand-transition-screen" id="sandTransitionScreen">
        <div class="transition-mandala">
            <canvas id="sandMandalaCanvas" class="sand-mandala-canvas" width="300" height="300"></canvas>
        </div>
        <p>"Hope you can have a good day!"</p>
    </section>

    <!-- River View -->
    <section class="river-view" id="riverViewScreen">
        <div class="river-info">
            <h2>River of Compassion</h2>
            <p>Each glowing light represents a mandala blessing sent by someone around the world.</p>
        </div>
        
        <div class="river">
            <div class="river-wave"></div>
            <!-- Mandala particles will be added dynamically -->
        </div>
        
        <div class="river-controls">
            <button id="backToHomeFromRiverBtn" class="secondary">Back to Home</button>
        </div>
    </section>

    <!-- Mandala Popup -->
    <div class="mandala-popup" id="mandalaPopup">
        <div class="popup-header">
            <h3 id="popupTitle">Mandala from Sydney, Australia</h3>
            <button class="popup-close" id="closePopupBtn">âœ•</button>
        </div>
        <div class="popup-content">
            <div class="popup-mandala" id="popupMandala"></div>
            <p class="popup-message" id="popupMessage">"Hope you can have a good day!"</p>
            <span class="popup-date" id="popupDate">May 1, 2025</span>
        </div>
    </div>

    <script>
        // DOM Elements
        const mainScreen = document.getElementById('mainScreen');
        const creationScreen = document.getElementById('creationScreen');
        const finalScreen = document.getElementById('finalScreen');
        const sandTransitionScreen = document.getElementById('sandTransitionScreen');
        const riverViewScreen = document.getElementById('riverViewScreen');
        const mandalaPopup = document.getElementById('mandalaPopup');
        
        const createBtn = document.getElementById('createBtn');
        const viewRiverBtn = document.getElementById('viewRiverBtn');
        
        const backToHomeFromCreationBtn = document.getElementById('backToHomeFromCreationBtn');
        const prevLevelBtn = document.getElementById('prevLevelBtn');
        const nextLevelBtn = document.getElementById('nextLevelBtn');
        const clearBtn = document.getElementById('clearBtn');
        
        const levelTitle = document.getElementById('levelTitle');
        const levelDescription = document.getElementById('levelDescription');
        
        const mandalaCanvas = document.getElementById('mandalaCanvas');
        const ctx = mandalaCanvas.getContext('2d');
        
        const finalMandalaCanvas = document.getElementById('finalMandalaCanvas');
        const finalCtx = finalMandalaCanvas.getContext('2d');
        
        const sandMandalaCanvas = document.getElementById('sandMandalaCanvas');
        const sandCtx = sandMandalaCanvas.getContext('2d');
        
        const backToEditBtn = document.getElementById('backToEditBtn');
        const sendMandalaBtn = document.getElementById('sendMandalaBtn');
        const mandalaMsgInput = document.getElementById('mandalaMsgInput');
        
        const backToHomeFromRiverBtn = document.getElementById('backToHomeFromRiverBtn');
        
        const closePopupBtn = document.getElementById('closePopupBtn');
        const popupTitle = document.getElementById('popupTitle');
        const popupMandala = document.getElementById('popupMandala');
        const popupMessage = document.getElementById('popupMessage');
        const popupDate = document.getElementById('popupDate');
        
        // State variables
        let currentLevel = 0;
        const levels = [
            { title: "Self", description: "Firstly, we send love to ourselves." },
            { title: "Loved ones", description: "Secondly, we send love to our loved ones." },
            { title: "Difficult person", description: "Thirdly, we send love to difficult person." },
            { title: "All beings", description: "Finally, we send love to all beings." }
        ];
        
        let isPouring = false;
        let selectedColor = "#3498db"; // Blue as default
        
        // Fixed dot size to start with
        const initialDotSize = 4;
        
        // Growth rate (pixels per animation frame)
        const growthRate = 0.03;
        
        // Animation variables
        let animationId = null;
        let pourX = 0;
        let pourY = 0;
        
        // Create texture pattern with noise
        function createSandTexture(color) {
            // Check if we already created this texture
            if (textureCache[color]) {
                return textureCache[color];
            }
            
            const textureCanvas = document.createElement('canvas');
            textureCanvas.width = 50;
            textureCanvas.height = 50;
            const textureCtx = textureCanvas.getContext('2d');
            
            // Parse the color to RGB components
            const r = parseInt(color.slice(1, 3), 16);
            const g = parseInt(color.slice(3, 5), 16);
            const b = parseInt(color.slice(5, 7), 16);
            
            // Fill with base color
            textureCtx.fillStyle = color;
            textureCtx.fillRect(0, 0, 50, 50);
            
            // Add noise texture
            const imageData = textureCtx.getImageData(0, 0, 50, 50);
            const data = imageData.data;
            
            for (let i = 0; i < data.length; i += 4) {
                // Random noise value (-15 to +15)
                const noise = Math.floor(Math.random() * 30) - 15;
                
                // Apply noise to RGB channels
                data[i] = Math.max(0, Math.min(255, r + noise));     // R
                data[i + 1] = Math.max(0, Math.min(255, g + noise)); // G
                data[i + 2] = Math.max(0, Math.min(255, b + noise)); // B
                // Keep alpha at full opacity
            }
            
            textureCtx.putImageData(imageData, 0, 0);
            const pattern = textureCtx.createPattern(textureCanvas, 'repeat');
            
            // Cache the pattern
            textureCache[color] = pattern;
            
            return pattern;
        }
        
        // Cache for texture patterns
        const textureCache = {};
        
        // Drawing layers for each level (4 layers)
        const layers = Array.from({ length: 4 }, () => {
            const canvas = document.createElement('canvas');
            canvas.width = mandalaCanvas.width;
            canvas.height = mandalaCanvas.height;
            return canvas;
        });
        
        // Store sand hills for each layer
        const sandHills = Array.from({ length: 4 }, () => []);
        
        // Sample mandala data for the river
        const worldMandalas = [
            {
                location: "Tokyo, Japan",
                message: "May peace flow through all living beings",
                date: "April 29, 2025",
                color: "#3498db" 
            },
            {
                location: "New York, USA",
                message: "Sending healing energy to those who need it",
                date: "April 28, 2025",
                color: "#2ecc71"
            },
            {
                location: "Sydney, Australia",
                message: "Hope you can have a good day!",
                date: "May 1, 2025",
                color: "#f1c40f"
            },
            {
                location: "Cape Town, South Africa",
                message: "May all beings find their inner light",
                date: "April 30, 2025",
                color: "#ffffff"
            },
            {
                location: "Paris, France",
                message: "Sending love and courage to everyone",
                date: "April 28, 2025",
                color: "#e74c3c"
            },
            {
                location: "Delhi, India",
                message: "May all find peace within themselves",
                date: "April 30, 2025",
                color: "#111111"
            }
        ];
        
        // Event Listeners
        createBtn.addEventListener('click', () => {
            showScreen(creationScreen);
            currentLevel = 0;
            updateLevel();
        });
        
        viewRiverBtn.addEventListener('click', () => {
            showScreen(riverViewScreen);
            setupRiver();
        });
        
        backToHomeFromCreationBtn.addEventListener('click', () => {
            showScreen(mainScreen);
        });
        
        prevLevelBtn.addEventListener('click', () => {
            if (currentLevel > 0) {
                currentLevel--;
                updateLevel();
            }
        });
        
        nextLevelBtn.addEventListener('click', () => {
            if (currentLevel < 3) {
                currentLevel++;
                updateLevel();
            } else {
                showFinalScreen();
            }
        });
        
        backToEditBtn.addEventListener('click', () => {
            showScreen(creationScreen);
        });
        
        sendMandalaBtn.addEventListener('click', () => {
            startSandTransition();
        });
        
        backToHomeFromRiverBtn.addEventListener('click', () => {
            showScreen(mainScreen);
        });
        
        closePopupBtn.addEventListener('click', () => {
            mandalaPopup.style.display = 'none';
        });
        
        clearBtn.addEventListener('click', clearCanvas);
        
        // Set up color swatches
        const colorTools = document.querySelector('.color-tools');
        const colorMeaning = document.querySelector('.color-meaning');
        
        const colorSymbols = [
            { color: '#ffffff', name: 'white', meaning: 'purity' },
            { color: '#3498db', name: 'blue', meaning: 'wisdom' },
            { color: '#f1c40f', name: 'yellow', meaning: 'illumination' },
            { color: '#e74c3c', name: 'red', meaning: 'passion' },
            { color: '#2ecc71', name: 'green', meaning: 'healing' },
            { color: '#111111', name: 'black', meaning: 'void' }
        ];
        
        // Create color swatches
        colorSymbols.forEach(item => {
            const swatch = document.createElement('div');
            swatch.className = `color-swatch color-${item.name}`;
            swatch.setAttribute('data-color', item.color);
            swatch.setAttribute('title', `${item.name.charAt(0).toUpperCase() + item.name.slice(1)} - ${item.meaning}`);
            if (item.name === 'blue') {
                swatch.classList.add('active');
            }
            colorTools.appendChild(swatch);
            
            swatch.addEventListener('click', () => {
                document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('active'));
                swatch.classList.add('active');
                selectedColor = swatch.getAttribute('data-color');
            });
        });
        
        // Create color meaning display
        colorSymbols.forEach(item => {
            const meaningItem = document.createElement('div');
            meaningItem.className = 'color-meaning-item';
            
            const dot = document.createElement('div');
            dot.className = 'color-meaning-dot';
            dot.style.backgroundColor = item.color;
            if (item.name === 'white') {
                dot.style.border = '1px solid #333';
            }
            
            const span = document.createElement('span');
            span.textContent = `${item.name.charAt(0).toUpperCase() + item.name.slice(1)} - ${item.meaning.split(',')[0]}`;
            
            meaningItem.appendChild(dot);
            meaningItem.appendChild(span);
            colorMeaning.appendChild(meaningItem);
        });
        
        // Canvas Event Listeners for drawing
        mandalaCanvas.addEventListener('mousedown', startPouring);
        mandalaCanvas.addEventListener('mouseup', stopPouring);
        mandalaCanvas.addEventListener('mouseleave', stopPouring);
        
        // Touch Event Listeners for mobile
        mandalaCanvas.addEventListener('touchstart', handleTouchStart);
        mandalaCanvas.addEventListener('touchend', stopPouring);
        mandalaCanvas.addEventListener('touchcancel', stopPouring);
        
        // Functions
        
        // Show specific screen, hide others
        function showScreen(screen) {
            mainScreen.style.display = 'none';
            creationScreen.style.display = 'none';
            finalScreen.style.display = 'none';
            sandTransitionScreen.style.display = 'none';
            riverViewScreen.style.display = 'none';
            
            screen.style.display = 'flex';
        }
        
        // Update level display and UI
        function updateLevel() {
            levelTitle.textContent = levels[currentLevel].title;
            levelDescription.textContent = levels[currentLevel].description;
            
            // Update navigation buttons
            prevLevelBtn.disabled = currentLevel === 0;
            nextLevelBtn.textContent = currentLevel === 3 ? "Complete" : "Next";
            
            // Update canvas to show current layer
            renderCanvas();
        }
        
        // Clear canvas and current layer
        function clearCanvas() {
            const layerCtx = layers[currentLevel].getContext('2d');
            layerCtx.clearRect(0, 0, layers[currentLevel].width, layers[currentLevel].height);
            
            // Clear sand hills for this layer
            sandHills[currentLevel] = [];
            
            // Update display
            renderCanvas();
        }
        
        // Start pouring sand
        function startPouring(e) {
            if (isPouring) return; // Already pouring
            
            isPouring = true;
            
            // Get click position
            const rect = mandalaCanvas.getBoundingClientRect();
            pourX = e.clientX - rect.left;
            pourY = e.clientY - rect.top;
            
            // Create a new sand hill
            const centerX = mandalaCanvas.width / 2;
            const centerY = mandalaCanvas.height / 2;
            
            // Calculate relative coordinates from center
            const relX = pourX - centerX;
            const relY = pourY - centerY;
            const distance = Math.sqrt(relX * relX + relY * relY);
            
            // Only create hill if click is within the current ring
            if (isPointInCurrentRing(distance)) {
                // Create new sand hill object
                const hill = {
                    x: pourX,
                    y: pourY,
                    size: initialDotSize,
                    color: selectedColor,
                    pouring: true,
                    symmetryPoints: []
                };
                
                // Calculate symmetry points
                const angle = Math.atan2(relY, relX);
                for (let i = 1; i < 8; i++) {
                    const newAngle = angle + (Math.PI / 4) * i;
                    const newX = centerX + distance * Math.cos(newAngle);
                    const newY = centerY + distance * Math.sin(newAngle);
                    
                    hill.symmetryPoints.push({
                        x: newX,
                        y: newY
                    });
                }
                
                // Add hill to current layer
                sandHills[currentLevel].push(hill);
                
                // Start animation to grow the hill
                if (!animationId) {
                    growHill();
                }
            }
        }
        
        // Handle touch start events
        function handleTouchStart(e) {
            e.preventDefault();
            if (e.touches.length === 1) {
                const touch = e.touches[0];
                // Create a mouse event to reuse the same logic
                const mouseEvent = {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                };
                startPouring(mouseEvent);
            }
        }
        
        // Stop pouring sand
        function stopPouring() {
            isPouring = false;
            // Animation will stop at next frame check
        }
        
        // Animation to grow hill with texture
        function growHill() {
            if (isPouring) {
                // Get the current layer's hills
                const hills = sandHills[currentLevel];
                
                // Get the last hill (the one we're currently building)
                if (hills.length > 0) {
                    const hill = hills[hills.length - 1];
                    
                    // Increase hill size
                    hill.size += growthRate;
                    
                    // Add pulsing animation during pouring
                    hill.pouring = true;
                    
                    // Redraw canvas
                    renderCanvas();
                }
                
                // Continue animation
                animationId = requestAnimationFrame(growHill);
            } else {
                // Set pouring to false for all hills to stop pulsing animation
                sandHills[currentLevel].forEach(hill => {
                    hill.pouring = false;
                });
                
                // Redraw canvas with final textured dots
                renderCanvas();
                
                // Stop animation when not pouring
                cancelAnimationFrame(animationId);
                animationId = null;
            }
        }
        
        // Check if point is in the current ring
        function isPointInCurrentRing(distance) {
            const radius = mandalaCanvas.width / 2;
            const ringWidth = radius / 4; // 4 rings
            
            const innerRadius = (currentLevel) * ringWidth;
            const outerRadius = (currentLevel + 1) * ringWidth;
            
            return distance >= innerRadius && distance <= outerRadius;
        }
        
        // Render the canvas with all layers and guides
        function renderCanvas() {
            ctx.clearRect(0, 0, mandalaCanvas.width, mandalaCanvas.height);
            
            // Draw ring guides
            drawRingGuides();
            
            // Draw all hills for each layer
            for (let level = 0; level < 4; level++) {
                const layerCtx = layers[level].getContext('2d');
                layerCtx.clearRect(0, 0, layers[level].width, layers[level].height);
                
                // Enable anti-aliasing for smoother circles
                layerCtx.imageSmoothingEnabled = true;
                layerCtx.imageSmoothingQuality = 'high';
                
                // Draw all hills for this layer
                sandHills[level].forEach(hill => {
                    // Get or create texture for this color
                    const texture = createSandTexture(hill.color);
                    
                    // Draw main hill with texture
                    layerCtx.beginPath();
                    layerCtx.arc(hill.x, hill.y, hill.size, 0, Math.PI * 2);
                    layerCtx.fillStyle = texture;
                    layerCtx.fill();
                    
                    // Add pulsing effect if currently pouring this hill
                    if (hill.pouring) {
                        const pulseSize = hill.size + 2 + Math.sin(Date.now() / 200) * 1;
                        layerCtx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                        layerCtx.lineWidth = 0.5;
                        layerCtx.beginPath();
                        layerCtx.arc(hill.x, hill.y, pulseSize, 0, Math.PI * 2);
                        layerCtx.stroke();
                    }
                    
                    // Draw symmetry points
                    hill.symmetryPoints.forEach(point => {
                        layerCtx.beginPath();
                        layerCtx.arc(point.x, point.y, hill.size, 0, Math.PI * 2);
                        layerCtx.fillStyle = texture;
                        layerCtx.fill();
                        
                        // Add pulsing effect to symmetry points if pouring
                        if (hill.pouring) {
                            const pulseSize = hill.size + 2 + Math.sin(Date.now() / 200) * 1;
                            layerCtx.beginPath();
                            layerCtx.arc(point.x, point.y, pulseSize, 0, Math.PI * 2);
                            layerCtx.stroke();
                        }
                    });
                });
                
                // Draw layer onto main canvas
                ctx.drawImage(layers[level], 0, 0);
            }
        }
        
        // Draw the concentric ring guides
        function drawRingGuides() {
            const radius = mandalaCanvas.width / 2;
            const ringWidth = radius / 4; // 4 rings
            const centerX = mandalaCanvas.width / 2;
            const centerY = mandalaCanvas.height / 2;
            
            for (let i = 1; i <= 4; i++) {
                ctx.beginPath();
                ctx.arc(centerX, centerY, i * ringWidth, 0, Math.PI * 2);
                ctx.strokeStyle = i === currentLevel + 1 ? 'rgba(255, 255, 255, 0.5)' : 'rgba(255, 255, 255, 0.2)';
                ctx.lineWidth = i === currentLevel + 1 ? 2 : 1;
                ctx.stroke();
            }
        }
        
        // Show final screen with completed mandala
        function showFinalScreen() {
            showScreen(finalScreen);
            
            // Resize and render the final mandala
            finalCtx.clearRect(0, 0, finalMandalaCanvas.width, finalMandalaCanvas.height);
            
            // Draw background
            finalCtx.fillStyle = 'black';
            finalCtx.fillRect(0, 0, finalMandalaCanvas.width, finalMandalaCanvas.height);
            
            // Scale and draw the mandala
            const scale = finalMandalaCanvas.width / mandalaCanvas.width;
            
            for (let level = 0; level < 4; level++) {
                const hills = sandHills[level];
                
                // Enable anti-aliasing for smoother circles
                finalCtx.imageSmoothingEnabled = true;
                finalCtx.imageSmoothingQuality = 'high';
                
                // Draw all hills for this layer
                hills.forEach(hill => {
                    // Get or create texture for this color
                    const texture = createSandTexture(hill.color);
                    
                    // Draw main hill with texture
                    finalCtx.beginPath();
                    finalCtx.arc(
                        hill.x * scale, 
                        hill.y * scale, 
                        hill.size * scale, 
                        0, Math.PI * 2
                    );
                    finalCtx.fillStyle = texture;
                    finalCtx.fill();
                    
                    // Draw symmetry points
                    hill.symmetryPoints.forEach(point => {
                        finalCtx.beginPath();
                        finalCtx.arc(
                            point.x * scale, 
                            point.y * scale, 
                            hill.size * scale, 
                            0, Math.PI * 2
                        );
                        finalCtx.fillStyle = texture;
                        finalCtx.fill();
                    });
                });
            }
        }
        
        // Start sand mandala transition
        function startSandTransition() {
            showScreen(sandTransitionScreen);
            
            // Copy the mandala to the sand canvas
            sandCtx.clearRect(0, 0, sandMandalaCanvas.width, sandMandalaCanvas.height);
            sandCtx.fillStyle = 'black';
            sandCtx.fillRect(0, 0, sandMandalaCanvas.width, sandMandalaCanvas.height);
            
            // Draw all hills from all layers onto the transition canvas
            const scale = sandMandalaCanvas.width / mandalaCanvas.width;
            
            // Collect all sand hill points for creating particles
            const particles = [];
            
            for (let level = 0; level < 4; level++) {
                sandHills[level].forEach(hill => {
                    // Draw main hill
                    sandCtx.fillStyle = hill.color;
                    sandCtx.beginPath();
                    sandCtx.arc(
                        hill.x * scale, 
                        hill.y * scale, 
                        hill.size * scale, 
                        0, Math.PI * 2
                    );
                    sandCtx.fill();
                    
                    // Add particles from this hill
                    addParticlesFromHill(particles, hill, scale);
                    
                    // Draw symmetry points
                    hill.symmetryPoints.forEach(point => {
                        sandCtx.beginPath();
                        sandCtx.arc(
                            point.x * scale, 
                            point.y * scale, 
                            hill.size * scale, 
                            0, Math.PI * 2
                        );
                        sandCtx.fill();
                        
                        // Add particles from symmetry point
                        addParticlesFromPoint(particles, point, hill.size, hill.color, scale);
                    });
                });
            }
            
            // Animation variables
            let frame = 0;
            const maxFrames = 180; // 3 seconds at 60fps
            
            // Animation function
            function animateSand() {
                frame++;
                
                // Clear canvas
                sandCtx.clearRect(0, 0, sandMandalaCanvas.width, sandMandalaCanvas.height);
                sandCtx.fillStyle = 'black';
                sandCtx.fillRect(0, 0, sandMandalaCanvas.width, sandMandalaCanvas.height);
                
                // Draw diminishing original mandala
                const alpha = Math.max(0, 1 - frame / (maxFrames * 0.6));
                
                if (alpha > 0) {
                    // Draw all hills from all layers with fading alpha
                    for (let level = 0; level < 4; level++) {
                        sandHills[level].forEach(hill => {
                            const texture = createSandTexture(hill.color);
                            
                            // Set global alpha for fading
                            sandCtx.globalAlpha = alpha;
                            
                            // Draw main hill
                            sandCtx.beginPath();
                            sandCtx.arc(
                                hill.x * scale, 
                                hill.y * scale, 
                                hill.size * scale, 
                                0, Math.PI * 2
                            );
                            sandCtx.fillStyle = texture;
                            sandCtx.fill();
                            
                            // Draw symmetry points
                            hill.symmetryPoints.forEach(point => {
                                sandCtx.beginPath();
                                sandCtx.arc(
                                    point.x * scale, 
                                    point.y * scale, 
                                    hill.size * scale, 
                                    0, Math.PI * 2
                                );
                                sandCtx.fillStyle = texture;
                                sandCtx.fill();
                            });
                            
                            // Reset alpha
                            sandCtx.globalAlpha = 1;
                        });
                    }
                }
                
                // Update and draw particles
                for (let i = 0; i < particles.length; i++) {
                    const p = particles[i];
                    
                    if (frame > maxFrames * 0.3) { // Start moving after 30% of animation
                        p.x += p.speedX;
                        p.y += p.speedY;
                    }
                    
                    // Only draw particles that are still in the canvas
                    if (p.y < sandMandalaCanvas.height) {
                        sandCtx.fillStyle = p.color;
                        sandCtx.beginPath();
                        sandCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                        sandCtx.fill();
                    }
                }
                
                // Continue animation or finish
                if (frame < maxFrames) {
                    requestAnimationFrame(animateSand);
                } else {
                    setTimeout(() => {
                        showScreen(riverViewScreen);
                        setupRiver();
                    }, 1000);
                }
            }
            
            // Start animation
            animateSand();
        }
        
        // Helper function to add particles from a hill
        function addParticlesFromHill(particles, hill, scale) {
            const centerX = sandMandalaCanvas.width / 2;
            const centerY = sandMandalaCanvas.height / 2;
            
            // Add particles based on the hill size
            const particleCount = Math.floor(hill.size * 5);
            
            for (let i = 0; i < particleCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * hill.size;
                
                particles.push({
                    x: (hill.x * scale) + Math.cos(angle) * distance * scale,
                    y: (hill.y * scale) + Math.sin(angle) * distance * scale,
                    color: hill.color,
                    size: Math.random() * 2 + 1,
                    speedX: (Math.random() - 0.5) * 2,
                    speedY: Math.random() * 3 + 1
                });
            }
        }
        
        // Helper function to add particles from a symmetry point
        function addParticlesFromPoint(particles, point, size, color, scale) {
            const particleCount = Math.floor(size * 5);
            
            for (let i = 0; i < particleCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * size;
                
                particles.push({
                    x: (point.x * scale) + Math.cos(angle) * distance * scale,
                    y: (point.y * scale) + Math.sin(angle) * distance * scale,
                    color: color,
                    size: Math.random() * 2 + 1,
                    speedX: (Math.random() - 0.5) * 2,
                    speedY: Math.random() * 3 + 1
                });
            }
        }
        
        // Setup river view with floating mandalas
        function setupRiver() {
            const river = document.querySelector('.river');
            river.innerHTML = '<div class="river-wave"></div>';
            
            // Add existing mandalas from the world
            worldMandalas.forEach((mandala, index) => {
                const xPos = 20 + Math.random() * 60; // 20% to 80% width
                const yPos = 50 + Math.random() * 40; // 60% to 90% height (in the river)
                
                const mandalaEl = document.createElement('div');
                mandalaEl.className = 'river-mandala';
                mandalaEl.style.left = `${xPos}%`;
                mandalaEl.style.top = `${yPos}%`;
                mandalaEl.innerHTML =  `<div class="world-mandalas" style="background-color: ${mandala.color};"> </div>`;
                
                mandalaEl.addEventListener('click', () => {
                    showMandalaPopup(mandala);
                });
                
                river.appendChild(mandalaEl);
                
                // Add random movement
                animateMandala(mandalaEl);
            });
            
            // Add sand particles for effect
            for (let i = 0; i < 50; i++) {
                createSandParticle();
            }
        }
        
        // Create a sand particle in the river
        function createSandParticle() {
            const river = document.querySelector('.river');
            const particle = document.createElement('div');
            particle.className = 'mandala-particle';
            
            const xPos = Math.random() * 100;
            const yPos = 50 + Math.random() * 60;
            particle.style.left = `${xPos}%`;
            particle.style.top = `${yPos}%`;
            
            // Random size
            const size = 4 + Math.random() * 8;
            particle.style.width = `${size}px`;
            particle.style.height = `${size}px`;
            
            // Random color tint
            const hue = 40 + Math.random() * 20; // Gold hues
            particle.style.backgroundColor = `hsl(${hue}, 80%, 75%)`;
            
            river.appendChild(particle);
            
            // Animate the particle
            const speed = 0.5 + Math.random() * 1;
            const direction = Math.random() > 0.5 ? 1 : -1;
            
            function moveParticle() {
                const currentLeft = parseFloat(particle.style.left);
                const newLeft = currentLeft + (speed * direction * 0.1);
                
                if (newLeft < -5 || newLeft > 105) {
                    // Remove particle if it's off screen
                    particle.remove();
                    // Create a new one
                    createSandParticle();
                } else {
                    particle.style.left = `${newLeft}%`;
                    requestAnimationFrame(moveParticle);
                }
            }
            
            moveParticle();
        }
        
        // Animate mandala in the river
        function animateMandala(mandalaEl) {
            const speed = 0.05 + Math.random() * 0.05;
            
            function moveMandala() {
                const currentLeft = parseFloat(mandalaEl.style.left);
                const newLeft = currentLeft - speed;
                
                if (newLeft < -5) {
                    // Reset position if it's off screen
                    mandalaEl.style.left = '105%';
                } else {
                    mandalaEl.style.left = `${newLeft}%`;
                }
                
                requestAnimationFrame(moveMandala);
            }
            
            moveMandala();
        }
        
        // Show popup with mandala details
        function showMandalaPopup(mandala) {
            popupTitle.textContent = `Mandala from ${mandala.location}`;
            popupMandala.style.backgroundImage = `url(${mandala.image})`;
            popupMessage.textContent = `"${mandala.message}"`;
            popupDate.textContent = mandala.date;
            
            mandalaPopup.style.display = 'block';
        }
        
        // Initialize on load
        window.addEventListener('load', () => {
            // Show main screen
            showScreen(mainScreen);
            
            // Ensure canvas is properly sized
            const resizeCanvas = () => {
                if (window.innerWidth < 768) {
                    mandalaCanvas.width = 300;
                    mandalaCanvas.height = 300;
                    
                    layers.forEach(layer => {
                        layer.width = 300;
                        layer.height = 300;
                    });
                } else {
                    mandalaCanvas.width = 500;
                    mandalaCanvas.height = 500;
                    
                    layers.forEach(layer => {
                        layer.width = 500;
                        layer.height = 500;
                    });
                }
                
                renderCanvas();
            };
            
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
        });
    </script>
</body>
</html>
